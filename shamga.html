<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Кибершамыга</title>
<style>
body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background-color: #111; color: white; touch-action: none; }
canvas { display: block; }
#menu-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
}
#menu {
    position: relative;
    padding: 40px 20px;
    background-color: rgba(20, 20, 20, 0.9);
    border-radius: 15px;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    z-index: 15;
    text-align: center;
    max-width: 90%;
    width: auto;
}
#menu h1 {
    font-size: 2.5em;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px #00ffff;
    z-index: 20;
}
#playButton, #skinsButton, #restartButton, #returnToMenuButton, #closeSkinsButton, #toggle-versions, #death-modal-content button, #skins-modal-content button, #mobile-controls-toggle, #current-difficulty {
    font-size: 1.2em;
    padding: 12px 20px;
    margin: 8px 0;
    cursor: pointer;
    z-index: 20;
    border: 2px solid #00ffff;
    background: linear-gradient(to right, #444, #222);
    color: white;
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
    transition: transform 0.2s, box-shadow 0.2s;
    width: 100%;
    max-width: 300px;
    white-space: nowrap; 
}
#playButton:hover, #skinsButton:hover, #restartButton:hover, #returnToMenuButton:hover, #closeSkinsButton:hover, #toggle-versions:hover, #death-modal-content button:hover, #skins-modal-content button:hover, #mobile-controls-toggle:hover, #current-difficulty:hover {
    transform: scale(1.00);
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
}


#difficulty-selector {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 10px;
    width: 100%;
    max-width: 350px; 
}

.difficulty-button {
    font-size: 1.2em;
    padding: 12px 20px;
    margin: 8px 0;
    cursor: pointer;
    z-index: 20;
    border: 2px solid #00ffff;
    background: linear-gradient(to right, #444, #222);
    color: white;
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
    transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
    width: 100%;
    max-width: 300px;
}

.difficulty-button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
}


#difficulty-options {
    display: flex;
    flex-direction: row; 
    justify-content: center; 
    gap: 10px;
    width: 100%;
    margin-top: 5px;
}

.difficulty-tab {
    width: auto; 
    padding: 2px 3px;
    font-size: 1em;
    cursor: pointer;
    border: 2px solid #00ffff;
    background: linear-gradient(to right, #444, #222);
    color: white;
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
    transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
    margin: 0;
}

.difficulty-tab:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
}

.difficulty-tab.selected {
    background: linear-gradient(to right, #00a0a0, #007070);
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.7);
    transform: scale(1.05);
    color: #fff;
    border-color: #99ffff;
}


#hud {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 20px;
    display: none;
    z-index: 1;
    border: 4px solid cyan;
    padding: 25px;
    border-radius: 15px;
    background-color: rgba(100, 149, 237, 0.7);
    width: auto;
    min-width: 250px;
    box-shadow: 0 0 20px rgba(100, 149, 237, 0.5);
    backdrop-filter: blur(5px);
}
#health-bar {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 220px;
    height: 25px;
    background-color: rgba(255, 0, 0, 0.6);
    display: none;
    z-index: 1;
    border-radius: 25px;
    border: 11px solid rgba(255, 0, 0, 0.8);
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
}
#health {
    height: 100%;
    background: linear-gradient(to right, green, limegreen);
    width: calc(100%);
    text-align: center;
    color: white;
    font-weight: bold;
    line-height: 25px;
    border-top-left-radius: 15px;
    border-bottom-left-radius: 15px;
    box-shadow: inset 0 0 5px rgba(0, 255, 0, 0.3);
}
#crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 25px;
    height: 25px;
    background-color: transparent;
    border: 3px solid red;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    display: none;
    z-index: 1;
    box-shadow: 0 0 10px red;
}
#death-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 25;
}
#death-modal-content {
    background-color: rgba(50, 50, 50, 0.95);
    padding: 30px 20px;
    border-radius: 15px;
    text-align: center;
    color: white;
    box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
    width: 90%;
    max-width: 90%;
}
#death-modal-content h2 {
    font-size: 2em;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px red;
}
#skins-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 25;
}
#skins-modal-content {
    background-color: rgba(50, 50, 50, 0.95);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    color: white;
    max-height: 80vh;
    overflow-y: auto;
    width: 90%;
    
    max-width: 1100px;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
}

#skins-list {
    display: grid;
    
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 15px; 
}

.skin-item {
    
    padding: 10px;
    border-radius: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: background-color 0.3s;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between; 
}


.skin-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}
.skin-item span {
    margin-right: 0;
    display: block;
    width: 100%;
    text-align: center;
    font-size: 1em;
    margin-bottom: 5px;
}
.selected-skin {
    background-color: rgba(0, 255, 0, 0.3);
    border: 1px solid limegreen;
}
#skins-list h3 {
    margin-top: 20px;
    margin-bottom: 10px;
    color: #00ffff;
    font-size: 1.2em;
    text-shadow: 1px 1px 2px #00ffff;
    
    grid-column: 1 / -1;
}
#skins-list hr {
    margin: 20px 0;
    border: none;
    height: 2px;
    background-color: rgba(255, 255, 255, 0.2);
    
    grid-column: 1 / -1;
}
#version {
    position: fixed;
    bottom: 5px;
    right: 5px;
    color: white;
    font-size: 10px;
    padding: 3px 6px;
    border: 2px solid;
    background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);
    background-size: 400% 100%;
    -webkit-background-clip: text;
    background-clip: padding-box;
    border: 2px solid transparent;
    --speed: 15s;
    animation: rainbow var(--speed) linear infinite;
    z-index: 20;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(128, 128, 128, 0.5);
    backdrop-filter: blur(3px);
    background-color: rgba(0, 0, 0, 0.5);
}
@keyframes rainbow {
    0% {
        background-position: 0% 50%;
    }
    100% {
        background-position: 100% 50%;
    }
}
#previous-kills {
    margin-bottom: 20px;
    font-size: 1.1em;
    z-index: 20;
	margin-top: 20px;
    text-shadow: 1px 1px 2px #00ffff;
}
.hud-container {
    display: flex;
    align-items: center;
    gap: 15px;
	position: absolute;
    top: 850px;
    left: 900px;
}
.weapon-slot {
    position: relative;
    width: 90px;
    height: 90px;
    border-radius: 15px;
    overflow: hidden;
    background-color: rgba(255,255,255,0.05);
    display: flex;
    align-items: center;
    justify-content: center;
    border: 4px solid cyan;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    transition: transform 0.3s;
}
.weapon-slot img {
    width: 110%;
    height: 110%;
    object-fit: contain;
    transform: scale(0.6);
    transition: transform 0.3s;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.8));
}
.weapon-slot img:hover {
    transform: scale(0.8);
    filter: drop-shadow(0 0 15px rgba(255, 255, 255, 1));
}
#weaponStatus {
    position: absolute;
    bottom: 60%;
    left: 25%;
    transform: translate(-50%, 0);
    font-size: 18px;
    color: white;
    z-index: 10;
    text-shadow: 1px 1px 2px #00ffff;
}
.weapon-number {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.6);
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 14px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}
.checkmark {
    border-radius: 50%;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 1.2em;
    text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
}
    #version-info {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 120px;
      background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 100;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
      max-height: 150px;
      overflow-y: auto;
      display: none;
      backdrop-filter: blur(5px);
      background-color: rgba(0, 0, 0, 0.7);
      width: 90%;
      max-width: 90%;
    }
#version-table {
  width: 100%;
  border-collapse: collapse;
  text-align: center;
  background: rgba(255, 127, 80, 0.8);
  border-radius: 5px;
  overflow: hidden;
  box-shadow: 0 0 5px rgba(255, 127, 80, 0.5);
}
#version-table th, #version-table td {
  border: 1px solid rgba(255, 255, 255, 0.2);
  padding: 5px;
  word-break: break-word;
  min-width: 80px;
  background: rgba(255, 127, 80, 0.8);
  font-size: 10px;
}
#version-table th {
  background: rgba(135, 206, 235, 0.9);
  color: #000;
  font-weight: bold;
  text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
}
#version-table tbody tr:nth-child(odd) {
  background: rgba(255, 127, 80, 0.7);
}
#version-table tbody tr:nth-child(even) {
  background: rgba(255, 127, 80, 0.7);
}
#version-table tbody tr:hover {
  background: rgba(255, 127, 80, 0.9);
}
#version-table td div {
  white-space: pre-wrap;
}
#version-info::-webkit-scrollbar {
  width: 6px;
}
#version-info::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 3px;
}
#version-info::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.6);
  border-radius: 3px;
}
#version-info::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.8);
}
#version-info {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.6) rgba(0, 0, 0, 0.3);
}
button {
  padding: 10px 15px;
  border: none;
  border-radius: 6px;
  background: linear-gradient(to right, #667eea, #764ba2);
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  box-shadow: 0 0 8px rgba(102, 126, 234, 0.7);
  width: 100%;
  max-width: 250px;
}
.hud-skin-preview {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 10px;
}
.preview-hud {
    width: 80px;
    height: 25px;
    border: 1px solid;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 5px;
    font-size: 0.7em;
}
.preview-health-bar {
    width: 80px;
    height: 10px;
    border: 1px solid;
    border-radius: 5px;
    overflow: hidden;
}
.preview-health {
    height: 100%;
    border-radius: 5px 0 0 5px;
}
.skin-info {
    display: flex;
    flex-direction: column;
    align-items: center;
}
.selected-button {
    background-color: #00cc00;
    box-shadow: 0 0 10px rgba(0, 204, 0, 0.8);
}
#mobile-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
    z-index: 100;
    pointer-events: none;
}

.mobile-control-group {
    position: absolute;
    bottom: 20px;
    pointer-events: none;
}

#joystick-container {
    left: 20px;
    width: 120px;
    height: 120px;
}

#action-buttons {
    right: 15px;
    bottom: 15px;
    width: 220px;
    height: 220px;
    pointer-events: auto;
}

.joystick-base {
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    pointer-events: auto;
    left: 10px;
    bottom: 10px;
}

.joystick-thumb {
    position: absolute;
    width: 50px;
    height: 50px;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    top: 25px;
    left: 25px;
    pointer-events: none;
}

.action-button {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.25);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    color: white;
    pointer-events: auto;
    user-select: none;
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.action-button img {
    width: 65%;
    height: 65%;
    object-fit: contain;
    pointer-events: none;
}

#shoot-button {
    background-color: rgba(255, 0, 0, 0.4);
    width: 90px;
    height: 90px;
    right: 10px;
    bottom: 10px;
    font-size: 40px;
}

#jump-button {
    background-color: rgba(0, 255, 0, 0.4);
    width: 75px;
    height: 75px;
    right: 115px;
    bottom: 25px;
}

#reload-button {
    background-color: rgba(255, 255, 0, 0.4);
    font-size: 22px;
    width: 65px;
    height: 65px;
    right: 35px;
    bottom: 115px;
}

#weapon1-button, #weapon2-button {
    width: 60px;
    height: 60px;
    display: flex;
}

#weapon1-button {
    background-color: rgba(0, 0, 255, 0.4);
    right: 110px;
    bottom: 110px;
}

#weapon2-button {
    background-color: rgba(255, 0, 255, 0.4);
    right: 100px;
    bottom: 170px;
}

#mobile-hud {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-size: 14px;
    display: none;
    flex-direction: column; 
    gap: 5px; 
    z-index: 1;
    border: 2px solid cyan;
    padding: 10px;
    border-radius: 10px;
    background-color: rgba(100, 149, 237, 0.7);
    width: auto;
    min-width: 120px;
    box-shadow: 0 0 10px rgba(100, 149, 237, 0.5);
    backdrop-filter: blur(5px);
}

#mobile-health-bar {
    position: absolute;
    left: 50%; 
    bottom: 10px; 
    transform: translateX(-50%); 
    width: 120px;
    height: 15px;
    background-color: rgba(255, 0, 0, 0.6);
    display: none;
    z-index: 1;
    border-radius: 10px;
    border: 6px solid rgba(255, 0, 0, 0.8);
    box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
}

#mobile-health {
    height: 100%;
    background: linear-gradient(to right, green, limegreen);
    width: calc(100%);
    text-align: center;
    color: white;
    font-weight: bold;
    line-height: 15px;
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
    box-shadow: inset 0 0 3px rgba(0, 255, 0, 0.3);
}

.mobile-hud-container {
    display: none !important; 
}

.mobile-weapon-slot {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 8px;
    overflow: hidden;
    background-color: rgba(255,255,255,0.05);
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid cyan;
    box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
    transition: transform 0.3s;
}

.mobile-weapon-slot img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transition: transform 0.3s;
    filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.8));
}

.mobile-weapon-slot img:hover {
    transform: scale(1.1);
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 1));
}

.mobile-weapon-number {
    position: absolute;
    top: 3px;
    right: 3px;
    background: rgba(0,0,0,0.6);
    padding: 2px 3px;
    border-radius: 3px;
    font-size: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
}

#mobile-ammo {
    font-size: 12px;
}

.required-kills-text {
    font-size: 0.8em;
    color: #aaa;
    margin-bottom: 5px;
    text-align: center;
}

@media (max-width: 768px) {
    #version {
        top: 10px;
        right: 10px;
        bottom: auto;
        font-size: 12px;
    }
    
    #menu {
        padding: 20px 15px; 
    }

    #menu h1 {
        font-size: 1.8em; 
        margin-bottom: 15px; 
    }
    
    #playButton, #skinsButton, #restartButton, #returnToMenuButton, #closeSkinsButton, #toggle-versions, #death-modal-content button, #skins-modal-content button, #mobile-controls-toggle, #current-difficulty, .difficulty-button {
        font-size: 1em;
        padding: 8px 15px; 
        margin: 5px 0; 
    }
    
    .difficulty-tab {
        padding: 8px 10px;
        font-size: 0.9em;
    }

    #previous-kills {
        font-size: 1em;
        margin: 10px 0;
    }
    
    #version-info {
        top: 100px;
        font-size: 10px;
        padding: 8px;
        max-height: 120px;
    }
    
    #version-table th, #version-table td {
        padding: 4px;
        min-width: 60px;
        font-size: 8px;
    }
    
    
    #skins-modal-content {
        padding: 15px;
        width: 95%;
        max-width: 95%;
    }

    #skins-list {
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
    }

    .skin-item {
        padding: 8px;
    }
    
    .skin-item span {
        font-size: 0.9em;
    }
    
    .preview-hud, .preview-health-bar {
        width: 70px;
    }
    .preview-hud {
        height: 22px;
        font-size: 0.6em;
    }
    .preview-health-bar {
        height: 8px;
    }
    
    .required-kills-text {
        font-size: 0.7em;
    }
   

    #death-modal-content {
        padding: 20px 15px;
    }
    
    #death-modal-content h2 {
        font-size: 1.8em;
        margin-bottom: 15px;
    }
}

@media (max-width: 920px) and (max-height: 450px) {
    #menu {
        padding: 10px 20px;
    }
    #menu h1 {
        font-size: 1.6em;
        margin-bottom: 8px;
    }
    #playButton, #skinsButton, #restartButton, #returnToMenuButton, #closeSkinsButton, #toggle-versions, #death-modal-content button, #skins-modal-content button, #mobile-controls-toggle, #current-difficulty, .difficulty-button {
        font-size: 0.9em;
        padding: 6px 12px;
        margin: 4px 0;
    }
    #previous-kills {
        font-size: 0.9em;
        margin: 8px 0;
    }
}

</style>
</head>
<body>
<div id="menu-container">
    <div id="menu-background"></div>
    <div id="menu">
	<button id="toggle-versions">
  Показать версии
</button>
<div id="version-info">
  <table id="version-table">
    <thead>
      <tr>
        <th colspan="2" style="text-align: center;">Версии:</th>
      </tr>
    </thead>
    <tbody>
	<tr>
        <td>0.0.1.0</td>
        <td>mobile-update</td>
      </tr>
	<tr>
        <td>0.0.0.9</td>
        <td>jump-hud-update</td>
      </tr>
      <tr>
        <td>0.0.0.8</td>
        <td>gun-update</td>
      </tr>
      <tr>
        <td>0.0.0.7</td>
        <td>boss-update</td>
      </tr>
      <tr>
        <td>0.0.0.6</td>
        <td>bug-fix(update)</td>
      </tr>
      <tr>
        <td>0.0.0.5</td>
        <td>generation-update</td>
      </tr>
      <tr>
        <td>0.0.0.4</td>
        <td>muzzleflash-update</td>
      </tr>
      <tr>
        <td>0.0.0.3</td>
        <td>enemysword-update</td>
      </tr>
      <tr>
        <td>0.0.0.2</td>
        <td>firstgun-update</td>
      </tr>
      <tr>
        <td>0.0.0.1</td>
        <td>release-кибершамыги</td>
      </tr>
    </tbody>
  </table>
</div>
        <h1>Кибершамыга</h1>
        
        <!-- ИЗМЕНЕННЫЙ БЛОК ВЫБОРА СЛОЖНОСТИ -->
        <div id="difficulty-selector">
            <button id="difficulty-toggle" class="difficulty-button">Выбор сложности</button>
            <div id="difficulty-options" style="display: none;">
                <button class="difficulty-tab" data-difficulty="easy">Легкий</button>
                <button class="difficulty-tab" data-difficulty="medium">Средний</button>
                <button class="difficulty-tab" data-difficulty="hard">Сложный</button>
            </div>
        </div>
        <!-- КОНЕЦ БЛОКА -->

        <button id="playButton">Играть</button>
        <button id="mobile-controls-toggle">Мобильное управление:Выкл</button>
        <span id="previous-kills"> Рекорд киллов: <span id="kills-display">0</span></span>
        <button id="skinsButton">Скины</button>
    </div>
</div>
<div id="skins-modal">
    <div id="skins-modal-content">
        <h2>Выбор скинов</h2>
        <div id="skins-list"></div>
        <button id="closeSkinsButton">Закрыть</button>
    </div>
</div>
<div id="death-modal">
    <div id="death-modal-content">
        <h2>Вы погибли!</h2>
        <button id="restartButton">Начать заново</button>
        <button id="returnToMenuButton">Вернуться в меню</button>
    </div>
</div>
<div id="hud">
<div class="hud-container">
        <div id="weapon1" class="weapon-slot">
            <img src="https://i.postimg.cc/cL1Ccm2P/image.webp" alt="Gun">
            <div class="weapon-number">1</div>
        </div>
        <div id="weapon2" class="weapon-slot" style="display: none;">
            <img src="https://i.postimg.cc/sgDyZcbL/image-1.webp" alt="Vape">
            <div class="weapon-number">2</div>
        </div>
    </div>
    <div>Время: <span id="time">00:00</span></div>
    <div>Киллы: <span id="kills">0</span></div>
    <div>Патроны: <span id="ammo"></span></div>
</div>
<div id="health-bar">
    <div id="health">88%</div>
</div>
<div id="mobile-hud">
    <div class="mobile-hud-container">
        <div id="mobile-weapon1" class="mobile-weapon-slot">
            <img src="https://i.postimg.cc/cL1Ccm2P/image.webp" alt="Gun">
            <div class="mobile-weapon-number">1</div>
        </div>
        <div id="mobile-weapon2" class="mobile-weapon-slot" style="display: none;">
            <img src="https://i.postimg.cc/sgDyZcbL/image-1.webp" alt="Vape">
            <div class="mobile-weapon-number">2</div>
        </div>
    </div>
    <div>Время: <span id="mobile-time">00:00</span></div>
    <div>Киллы: <span id="mobile-kills">0</span></div>
    <div id="mobile-ammo">Патроны: <span>-</span></div>
</div>
<div id="mobile-health-bar">
    <div id="mobile-health">88%</div>
</div>
<div id="crosshair"></div>
<div id="mobile-controls">
    <div id="joystick-container" class="mobile-control-group">
        <div class="joystick-base" id="joystick-base">
            <div class="joystick-thumb" id="joystick-thumb"></div>
        </div>
    </div>
    <div id="action-buttons" class="mobile-control-group">
        <div class="action-button" id="weapon2-button"><img src="https://i.postimg.cc/sgDyZcbL/image-1.webp" alt="Vape"></div>
        <div class="action-button" id="weapon1-button"><img src="https://i.postimg.cc/cL1Ccm2P/image.webp" alt="Gun"></div>
        <div class="action-button" id="reload-button">R</div>
        <div class="action-button" id="jump-button">↑</div>
        <div class="action-button" id="shoot-button">🔥</div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.148/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
<script>
let gameScene, gameCamera, gameRenderer, playerObject;

let currentPlayerHealth = 100;
let baseEnemyHealth = 25;
let currentEnemyDamage = 2;
let baseBossHealth = 100;
let currentBossDamage = 2;
let currentBossLevel = 1;
let isBossAlreadySpawned = false;
let timeToNextBossSpawn = 300;

let currentBulletSpeed = 50.0;
let gameStartTimeEpoch;
let gameEndTimeEpoch;

let killCount = 0;
let recordKillCount = 0;

let gunMuzzleFlash;
let muzzleFlashCurrentDuration = 0;
let muzzleFlashEndTimeEpoch = 0;

let gunMagazineSize = 10;
let currentGunAmmo = gunMagazineSize;
let displayedGunAmmo = gunMagazineSize;
let isGunReloading = false;

let isGameCurrentlyActive = false;
let isMouseButtonDown = false;
let shootIntervalTimerId = null;
let lastGunShotTime = 0;
const gunShotInterval = 0.2;

let isPlayerJumping = false;
let canPlayerJump = true;
const playerJumpStrength = 10.0;
const gameGravity = 20.0;

let currentDifficulty = 'medium'; 
const difficultySettings = {
    easy: { name: "Легкий", enemyHealth: 5, bossHealth: 50 },
    medium: { name: "Средний", enemyHealth: 15, bossHealth: 100 },
    hard: { name: "Сложный", enemyHealth: 25, bossHealth: 300 }
};

let weaponSkins = {
    default: {
        name: "Стандартный",
        unlocked: true,
        model: null,
        type: "weapon"
    },
    golden: {
        name: "Золотой",
        unlocked: true,
        model: null,
        type: "weapon"
    }
};

let hudSkins = {
    default: {
        name: "Стандартный HUD",
        unlocked: true,
		requiredKills: 0,
        colors: {
            border: "cyan",
            background: "rgba(100, 149, 237, 0.7)",
            health: "linear-gradient(to right, green, limegreen)",
            healthBg: "rgba(255, 0, 0, 0.6)",
            text: "white",
            healthBorder: "cyan"
        }
    },
    neon: {
        name: "Кибершамыга 2 HUD",
        unlocked: false,
		requiredKills: 100,
        colors: {
            border: "#00ffff",
            background: "rgba(0, 0, 51, 0.8)",
            health: "linear-gradient(to right, #00ff00, #00ffff)",
            healthBg: "rgba(51, 0, 51, 0.7)",
            text: "#006ebd",
            healthBorder: "#00ffff"
        }
    },
    retro: {
        name: "Классик HUD",
        unlocked: false,
		requiredKills: 500,
        colors: {
            border: "#ffff00",
            background: "rgba(139, 69, 19, 0.8)",
            health: "linear-gradient(to right, #32cd32, #90ee90)",
            healthBg: "rgba(139, 0, 0, 0.7)",
            text: "#ffff00",
            healthBorder: "#ffff00"
        }
    },
    futuristic: {
        name: "Кибертанк HUD",
        unlocked: false,
		requiredKills: 1000,
        colors: {
            border: "#ffffff",
            background: "rgba(0, 10, 30, 0.9)",
            health: "linear-gradient(to right, #00ffaa, #ccffff)",
            healthBg: "rgba(0, 51, 102, 0.8)",
            text: "#ffffff",
            healthBorder: "#ffffff"
        }
    },
    military: {
        name: "Вартандер HUD",
        unlocked: false,
		requiredKills: 5000,
        colors: {
            border: "#8fbc8f",
            background: "rgba(51, 51, 51, 0.9)",
            health: "linear-gradient(to right, #8fbc8f, #cceecc)",
            healthBg: "rgba(58, 58, 58, 0.8)",
            text: "#f0e68c",
            healthBorder: "#8fbc8f"
        }
    }
};

let currentWeaponSkin = 'default';
let currentHudSkin = 'default';

let gunReloadAnimationProgress = 0;
let isGunAnimatingReload = false;
const gunReloadAnimationDuration = 1.5;

const gameEnemies = [];
let gameBoss = null;
let bossWeaponGroup = null;
let bossLastFireTime = 0;
const bossFireInterval = 2;
let currentEnemySpeed = 5.0;
let maxActiveEnemies = 25;
let lastDifficultyIncreaseGameTime;

const gameBullets = [];
let playerGameBullets = [];

let gameTileSize = 150;
let gameTiles = {};
let gameTileMeshes = {};
const gameTrees = [];
let gameTreeMeshes = {};
let gameTreeInstances = {};

const skinsButtonElement = document.getElementById('skinsButton');
const skinsModalElement = document.getElementById('skins-modal');
const closeSkinsButtonElement = document.getElementById('closeSkinsButton');

skinsButtonElement.addEventListener('click', function(event) {
    event.stopPropagation();
    skinsModalElement.style.display = 'flex';
    updateSkinsMenuDisplay();
});
closeSkinsButtonElement.addEventListener('click', function(event) {
    event.stopPropagation();
    skinsModalElement.style.display = 'none';
});

let gunWeaponGroup, gunWeaponBody, gunWeaponMagazine;
let vapeWeaponGroup;
let vapeWeaponAmmo = 25;
let currentVapeWeaponAmmo = vapeWeaponAmmo;
const vapeAmmoRegenerationRate = 5;
let gameClock = new THREE.Clock();
let currentEquippedWeaponId = '';
let bossDroppedVapeWeapon = null;
let hasPlayerPickedUpVapeWeapon = false;

const availableWeapons = [
  { id: 'weapon1', name: 'Gun',     equipped: false  },
  { id: 'weapon2', name: 'Vape',    equipped: false },
];

let isDigitKey1Pressed = false;
let isDigitKey2Pressed = false;

let isMobileControlsEnabled = false;
let joystickDeltaX = 0;
let joystickDeltaY = 0;
let isJoystickActive = false;

let isMovingForward = false;
let isMovingBackward = false;
let isMovingLeft = false;
let isMovingRight = false;
const playerVelocity = new THREE.Vector3();
const playerDirection = new THREE.Vector3();


const setActiveDifficultyTab = (selectedDifficulty) => {
    currentDifficulty = selectedDifficulty;
    const difficultyTabs = document.querySelectorAll('.difficulty-tab');
    difficultyTabs.forEach(tab => {
        if (tab.dataset.difficulty === selectedDifficulty) {
            tab.classList.add('selected');
        } else {
            tab.classList.remove('selected');
        }
    });
};

document.addEventListener('DOMContentLoaded', () => {
    const versionInfoElement = document.getElementById('version-info');
    const playButtonElement = document.getElementById('playButton');
    playButtonElement.addEventListener('click', () => {
        versionInfoElement.style.display = 'none';
    });

    const mobileControlsToggle = document.getElementById('mobile-controls-toggle');
    mobileControlsToggle.addEventListener('click', function() {
        isMobileControlsEnabled = !isMobileControlsEnabled;
        this.textContent = `Мобильное управление: ${isMobileControlsEnabled ? 'Вкл' : 'Выкл'}`;
    });

    
    const difficultyToggle = document.getElementById('difficulty-toggle');
    const difficultyOptions = document.getElementById('difficulty-options');
    const difficultyTabs = document.querySelectorAll('.difficulty-tab');

    
    difficultyToggle.addEventListener('click', () => {
        if (difficultyOptions.style.display === 'none' || difficultyOptions.style.display === '') {
            difficultyOptions.style.display = 'flex';
        } else {
            difficultyOptions.style.display = 'none';
        }
    });

    
    difficultyTabs.forEach(tab => {
        tab.addEventListener('click', (event) => {
            const selectedDifficulty = event.target.dataset.difficulty;
            setActiveDifficultyTab(selectedDifficulty);
        });
    });

    setActiveDifficultyTab('medium');
});


 const toggleVersionButton = document.getElementById('toggle-versions');
const versionInfoDisplayElement = document.getElementById('version-info');

toggleVersionButton.addEventListener('click', () => {
  if (versionInfoDisplayElement.style.display === 'none' || !versionInfoDisplayElement.style.display) {
    versionInfoDisplayElement.style.display = 'block';
    toggleVersionButton.textContent = 'Скрыть версии';
  } else {
    versionInfoDisplayElement.style.display = 'none';
    toggleVersionButton.textContent = 'Показать версии';
  }
});

document.addEventListener('keydown', function(event) {
    if (!isGameCurrentlyActive || isMobileControlsEnabled) return;

    if (
        event.code === 'KeyW' ||
        event.code === 'KeyA' ||
        event.code === 'KeyS' ||
        event.code === 'KeyD' ||
        event.code === 'KeyR' ||
        event.code === 'Space'
    ) {
        event.preventDefault();
    }
	
    switch (event.code) {
        case 'KeyW':
            isMovingForward = true;
            break;
        case 'KeyS':
            isMovingBackward = true;
            break;
        case 'KeyA':
            isMovingLeft = true;
            break;
        case 'KeyD':
            isMovingRight = true;
            break;
        case 'KeyR':
            reloadGun();
            break;
        case 'Space':
            if (canPlayerJump && !isPlayerJumping) {
                isPlayerJumping = true;
                canPlayerJump = false;
                playerVelocity.y = playerJumpStrength;
            }
            break;
    }
	
	if (event.code === 'Digit1') {
        const weapon1 = availableWeapons.find(weapon => weapon.id === 'weapon1');
        if (!weapon1) return;

        if (!isDigitKey1Pressed || weapon1.equipped) {
            weapon1.equipped = !weapon1.equipped;
            if (weapon1.equipped) {
                currentEquippedWeaponId = 'weapon1';
            } else {
                currentEquippedWeaponId = '';
            }

            const weapon2 = availableWeapons.find(weapon => weapon.id === 'weapon2');
            if (hasPlayerPickedUpVapeWeapon && weapon2.equipped) {
                weapon2.equipped = false;
            }

            updateHUDDisplay();
        }

        isDigitKey1Pressed = true;
    } else if (event.code === 'Digit2' && hasPlayerPickedUpVapeWeapon) {
        const weapon2 = availableWeapons.find(weapon => weapon.id === 'weapon2');
        if (!weapon2) return;

        if (!isDigitKey2Pressed || weapon2.equipped) {
            weapon2.equipped = !weapon2.equipped;
            if (weapon2.equipped) {
                currentEquippedWeaponId = 'weapon2';
            } else {
                currentEquippedWeaponId = '';
            }

            const weapon1 = availableWeapons.find(weapon => weapon.id === 'weapon1');
            if (weapon1.equipped) {
                weapon1.equipped = false;
            }

            updateHUDDisplay();
        }

        isDigitKey2Pressed = true;
    }
});

document.addEventListener('keyup', function(event) {
    if (!isGameCurrentlyActive || isMobileControlsEnabled) return;

    if (
        event.code === 'KeyW' ||
        event.code === 'KeyA' ||
        event.code === 'KeyS' ||
        event.code === 'KeyD'
    ) {
        event.preventDefault();
    }
    switch (event.code) {
        case 'KeyW':
            isMovingForward = false;
            break;
        case 'KeyS':
            isMovingBackward = false;
            break;
        case 'KeyA':
            isMovingLeft = false;
            break;
        case 'KeyD':
            isMovingRight = false;
            break;
    }
	
	if (event.code === 'Digit1') {
        isDigitKey1Pressed = false;
    } else if (event.code === 'Digit2') {
        isDigitKey2Pressed = false;
    }
});

function setEquippedWeapon(weaponId) {
  if (currentEquippedWeaponId === weaponId) {
    currentEquippedWeaponId = '';
  } else {
    currentEquippedWeaponId = weaponId;
  }
  availableWeapons.forEach(weapon => {
    weapon.equipped = (weapon.id === currentEquippedWeaponId);
  });
  updateHUDDisplay();
}

function regenerateVapeAmmo(deltaTime) {
    if (currentEquippedWeaponId === 'weapon2' && currentVapeWeaponAmmo < vapeWeaponAmmo) {
        currentVapeWeaponAmmo += vapeAmmoRegenerationRate * deltaTime;
        if (currentVapeWeaponAmmo > vapeWeaponAmmo) {
            currentVapeWeaponAmmo = vapeWeaponAmmo;
        }
        updateHUDDisplay();
    }
}

function createVapeWeaponModel() {
    vapeWeaponGroup = new THREE.Group();
    const vapeBodyGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 32);
    const vapeBodyMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF });
    const vapeBody = new THREE.Mesh(vapeBodyGeometry, vapeBodyMaterial);
    vapeBody.position.set(0, 0, 0);
    vapeWeaponGroup.add(vapeBody);

    const mouthPieceGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 32);
    const mouthPieceMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
    const mouthPiece = new THREE.Mesh(mouthPieceGeometry, mouthPieceMaterial);
    mouthPiece.position.set(0, 0.25, 0);
    vapeBody.add(mouthPiece);

    vapeWeaponGroup.position.set(0.2, -0.2, -0.5);
    vapeWeaponGroup.visible = false;
    gameCamera.add(vapeWeaponGroup);
}

function updateHUDDisplay() {
    const timeElement = document.getElementById('time');
    const killsElement = document.getElementById('kills');
    const mobileTimeElement = document.getElementById('mobile-time');
    const mobileKillsElement = document.getElementById('mobile-kills');
    
    let elapsedTime;
    if (isGameCurrentlyActive) {
        const currentTime = new Date().getTime();
        elapsedTime = Math.floor((currentTime - gameStartTimeEpoch) / 1000);
    } else {
        elapsedTime = gameEndTimeEpoch && gameStartTimeEpoch ? Math.floor((gameEndTimeEpoch - gameStartTimeEpoch) / 1000) : 0;
    }
    const minutes = Math.floor(elapsedTime / 60);
    const seconds = elapsedTime % 60;
    const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    availableWeapons.forEach(weapon => {
        weapon.equipped = (weapon.id === currentEquippedWeaponId);
    });

    if (currentEquippedWeaponId === 'weapon1') {
        if (gunWeaponGroup) gunWeaponGroup.visible = true;
        if (vapeWeaponGroup) vapeWeaponGroup.visible = false;
    } else if (currentEquippedWeaponId === 'weapon2') {
        if (gunWeaponGroup) gunWeaponGroup.visible = false;
        if (vapeWeaponGroup) vapeWeaponGroup.visible = true;
    } else { 
        if (gunWeaponGroup) gunWeaponGroup.visible = false;
        if (vapeWeaponGroup) vapeWeaponGroup.visible = false;
    }

    if (isMobileControlsEnabled) {
        const mobileAmmoElement = document.querySelector('#mobile-ammo span');
        mobileTimeElement.textContent = timeText;
        mobileKillsElement.textContent = killCount;

        if (currentEquippedWeaponId === 'weapon1') {
            mobileAmmoElement.textContent = isGunReloading ? 'Перезарядка.' : `${displayedGunAmmo}/∞`;
        } else if (currentEquippedWeaponId === 'weapon2') {
            mobileAmmoElement.textContent = `${Math.floor(currentVapeWeaponAmmo)}/${vapeWeaponAmmo}`;
        } else {
            mobileAmmoElement.textContent = '-';
        }
        
        availableWeapons.forEach(({ id, equipped }) => {
            const mobileButton = document.getElementById(`${id}-button`);
            if (!mobileButton) return;
            
            if (id === 'weapon2') {
                mobileButton.style.display = hasPlayerPickedUpVapeWeapon ? 'flex' : 'none';
            }

            if (equipped) {
                if (id === 'weapon1') mobileButton.style.backgroundColor = 'rgba(0, 0, 255, 0.4)';
                else if (id === 'weapon2') mobileButton.style.backgroundColor = 'rgba(255, 0, 255, 0.4)';
            } else {
                mobileButton.style.backgroundColor = 'rgba(255, 0, 0, 0.4)';
            }
        });
    } else {
        const ammoElement = document.getElementById('ammo');
        timeElement.textContent = timeText;
        killsElement.textContent = killCount;
        
        if (currentEquippedWeaponId === 'weapon1') {
            ammoElement.textContent = isGunReloading ? 'Перезарядка.' : `${displayedGunAmmo}/∞`;
        } else if (currentEquippedWeaponId === 'weapon2') {
            ammoElement.textContent = `${Math.floor(currentVapeWeaponAmmo)}/${vapeWeaponAmmo}`;
        } else {
            ammoElement.textContent = '-';
        }
        
        availableWeapons.forEach(({ id, equipped }) => {
            const pcSlot = document.getElementById(id);
            if (!pcSlot) return;

            if (id === 'weapon2') {
                pcSlot.style.display = hasPlayerPickedUpVapeWeapon ? 'flex' : 'none';
            }
            
            const check = pcSlot.querySelector('.checkmark');
            if (equipped) {
                pcSlot.classList.add('equipped');
                pcSlot.style.backgroundColor = '';
                if (!check) {
                    const newCheck = document.createElement('div');
                    newCheck.className = 'checkmark';
                    newCheck.style.backgroundColor = 'limegreen';
                    pcSlot.appendChild(newCheck);
                } else if (check) {
                    check.style.backgroundColor = 'limegreen';
                }
            } else {
                pcSlot.classList.remove('equipped');
                pcSlot.style.backgroundColor = 'rgba(255, 0, 0, 0.4)';
                if (check) {
                    pcSlot.removeChild(check);
                }
            }
        });
    }
}


function createVapeBullet() {
    for (let i = 0; i < 3; i++) {
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.userData.isVapeBullet = true;
        bullet.userData.damage = 1;

        const cameraWorldPosition = new THREE.Vector3();
        gameCamera.getWorldPosition(cameraWorldPosition);
        const cameraWorldDirection = new THREE.Vector3();
        gameCamera.getWorldDirection(cameraWorldDirection);

        const spreadAngle = (i - 1) * 0.1;
        const bulletDirection = cameraWorldDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);

        const bulletStartPositionOffset = bulletDirection.clone().multiplyScalar(1);
        bullet.position.copy(cameraWorldPosition).add(bulletStartPositionOffset);
        bullet.userData.direction = bulletDirection.clone();
        bullet.userData.speed = 10.0;

        gameScene.add(bullet);
        playerGameBullets.push(bullet);
    }
    currentVapeWeaponAmmo -= 3;
    updateHUDDisplay();
}

function createGunWeaponModel() {
    gunWeaponGroup = new THREE.Group();
    const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
    const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
    gunWeaponBody = new THREE.Mesh(gunGeometry, gunMaterial);
    gunWeaponBody.position.set(0, 0, 0);
    gunWeaponGroup.add(gunWeaponBody);
    const handleGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.1);
    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
    handle.position.set(0, -0.15, -0.2);
    gunWeaponGroup.add(handle);
    const magazineGeometry = new THREE.BoxGeometry(0.04, 0.1, 0.1);
    const magazineMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
    gunWeaponMagazine = new THREE.Mesh(magazineGeometry, magazineMaterial);
    gunWeaponMagazine.position.set(0, -0.25, -0.2);
    gunWeaponGroup.add(gunWeaponMagazine);
    const muzzleFlashGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
    const muzzleFlashMaterial = new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
    });
    gunMuzzleFlash = new THREE.Mesh(muzzleFlashGeometry, muzzleFlashMaterial);
    gunMuzzleFlash.position.set(0, 0, -0.25);
    gunMuzzleFlash.rotation.x = Math.PI / 2;
    gunMuzzleFlash.visible = false;
    gunWeaponBody.add(gunMuzzleFlash);
}

function createBossWeaponModel() {
    bossWeaponGroup = new THREE.Group();
    const vapeBodyGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 32);
    const vapeBodyMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const vapeBody = new THREE.Mesh(vapeBodyGeometry, vapeBodyMaterial);
    vapeBody.position.set(0, 0, 0);
    bossWeaponGroup.add(vapeBody);
    const mouthPieceGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 32);
    const mouthPieceMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
    const mouthPiece = new THREE.Mesh(mouthPieceGeometry, mouthPieceMaterial);
    mouthPiece.position.set(0, 0.25, 0);
    vapeBody.add(mouthPiece);
    bossWeaponGroup.position.set(0, -0.5, 0.25);
    bossWeaponGroup.rotation.set(0, 0, 0);
    gameBoss.add(bossWeaponGroup);
}

function updateGunSkin() {
    if (currentWeaponSkin === 'golden') {
        gunWeaponBody.material.color.set(0xFFD700);
    } else {
        gunWeaponBody.material.color.set(0x333333);
    }
}

function createHudSkinPreview(skinKey) {
    const skin = hudSkins[skinKey];
    const previewContainer = document.createElement('div');
    previewContainer.className = 'hud-skin-preview';

    const healthBarPreview = document.createElement('div');
    healthBarPreview.className = 'preview-health-bar';
    healthBarPreview.style.background = skin.colors.healthBg;
    healthBarPreview.style.borderColor = skin.colors.healthBorder;
    healthBarPreview.style.borderWidth = '2px';
    healthBarPreview.style.borderStyle = 'solid';

    const healthPreview = document.createElement('div');
    healthPreview.className = 'preview-health';
    healthPreview.style.background = skin.colors.health;
    healthPreview.style.width = '70%';

    const hudPreview = document.createElement('div');
    hudPreview.className = 'preview-hud';
    hudPreview.style.background = skin.colors.background;
    hudPreview.style.borderColor = skin.colors.border;
    hudPreview.style.borderWidth = '2px';
    hudPreview.style.borderStyle = 'solid';
    hudPreview.style.color = skin.colors.text;
    hudPreview.textContent = 'HUD';

    healthBarPreview.appendChild(healthPreview);
    previewContainer.appendChild(hudPreview);
    previewContainer.appendChild(healthBarPreview);

    return previewContainer;
}

function updateSkinsMenuDisplay() {
    const skinsList = document.getElementById('skins-list');
    skinsList.innerHTML = '';

    let weaponSectionTitle = document.createElement('h3');
    weaponSectionTitle.textContent = 'Скины оружия';
    skinsList.appendChild(weaponSectionTitle);

    for (let key in weaponSkins) {
        let skin = weaponSkins[key];
        let skinDiv = document.createElement('div');
        skinDiv.className = 'skin-item';
        let skinName = document.createElement('span');
        skinName.textContent = skin.name;
        let selectButton = document.createElement('button');
        selectButton.textContent = 'Выбрать';
        selectButton.disabled = !skin.unlocked;
        selectButton.addEventListener('click', function () {
            currentWeaponSkin = key;
            skinsModalElement.style.display = 'none';
            updateGunSkin();
            updateSkinsMenuDisplay(); 
        });

        if (key === currentWeaponSkin) {
            skinDiv.classList.add('selected-skin');
            selectButton.textContent = 'Выбрано';
            selectButton.classList.add('selected-button');
        } else {
            selectButton.textContent = 'Выбрать';
            selectButton.classList.remove('selected-button');
        }


        if (!skin.unlocked) {
            let lockSpan = document.createElement('span');
            lockSpan.textContent = '🔒 Требуется 1000 киллов';
            skinDiv.appendChild(lockSpan);
        }
        skinDiv.appendChild(skinName);
        skinDiv.appendChild(selectButton);
        skinsList.appendChild(skinDiv);
    }

    let separator = document.createElement('hr');
    skinsList.appendChild(separator);

    let hudSectionTitle = document.createElement('h3');
    hudSectionTitle.textContent = 'Скины HUD';
    skinsList.appendChild(hudSectionTitle);

    for (let key in hudSkins) {
        let skin = hudSkins[key];
        let skinDiv = document.createElement('div');
        skinDiv.className = 'skin-item';

        let skinInfo = document.createElement('div');
        skinInfo.className = 'skin-info';

        let skinName = document.createElement('span');
        skinName.textContent = skin.name;
        skinInfo.appendChild(skinName);

        let preview = createHudSkinPreview(key);
        skinInfo.appendChild(preview);

        skinDiv.appendChild(skinInfo);

        let buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.flexDirection = 'column';
        buttonContainer.style.alignItems = 'center';

        if (!skin.unlocked && recordKillCount < skin.requiredKills) {
            let lockSpan = document.createElement('div');
            lockSpan.textContent = `🔒 Требуется ${skin.requiredKills} киллов`;
            lockSpan.className = 'required-kills-text';
            buttonContainer.appendChild(lockSpan);
        }

        let selectButton = document.createElement('button');
        selectButton.textContent = key === currentHudSkin ? 'Выбрано' : 'Выбрать';
        selectButton.disabled = !skin.unlocked && recordKillCount < skin.requiredKills;
        selectButton.className = key === currentHudSkin ? 'selected-button' : '';
        buttonContainer.appendChild(selectButton);

        skinDiv.appendChild(buttonContainer);

        selectButton.addEventListener('click', function () {
            if (recordKillCount >= skin.requiredKills || skin.unlocked) {
                currentHudSkin = key;
                applyHudSkin(key);
                updateSkinsMenuDisplay();
            }
        });

        if (key === currentHudSkin) {
            skinDiv.classList.add('selected-skin');
        }


        skinsList.appendChild(skinDiv);
    }
}

function applyHudSkin(skinKey) {
    const skin = hudSkins[skinKey];
    if (!skin) return;

    const hudElement = document.getElementById('hud');
    const healthBarElement = document.getElementById('health-bar');
    const healthElement = document.getElementById('health');
    const weaponSlotElements = document.querySelectorAll('.weapon-slot');

    hudElement.style.borderColor = skin.colors.border;
    hudElement.style.background = skin.colors.background;
    hudElement.style.color = skin.colors.text;

    healthBarElement.style.borderColor = skin.colors.border;
    healthBarElement.style.backgroundColor = skin.colors.healthBg;
    healthElement.style.background = skin.colors.health;
    healthElement.style.color = skin.colors.text;

    weaponSlotElements.forEach(slot => {
        slot.style.borderColor = skin.colors.border;
        slot.style.borderImage = 'none';
    });

    const mobileHudElement = document.getElementById('mobile-hud');
    const mobileHealthBarElement = document.getElementById('mobile-health-bar');
    const mobileHealthElement = document.getElementById('mobile-health');
    const mobileWeaponSlotElements = document.querySelectorAll('.mobile-weapon-slot');

    mobileHudElement.style.borderColor = skin.colors.border;
    mobileHudElement.style.background = skin.colors.background;
    mobileHudElement.style.color = skin.colors.text;

    mobileHealthBarElement.style.borderColor = skin.colors.border;
    mobileHealthBarElement.style.backgroundColor = skin.colors.healthBg;
    mobileHealthElement.style.background = skin.colors.health;
    mobileHealthElement.style.color = skin.colors.text;

    mobileWeaponSlotElements.forEach(slot => {
        slot.style.borderColor = skin.colors.border;
        slot.style.borderImage = 'none';
    });


    localStorage.setItem('selectedHudSkin', skinKey);
}

function saveSkinsUnlockStatus() {
    localStorage.setItem('skins', JSON.stringify({
        goldenUnlocked: weaponSkins.golden.unlocked,
        selectedHudSkin: currentHudSkin,
		neonHUDUnlocked: hudSkins.neon.unlocked,
		retroHUDUnlocked: hudSkins.retro.unlocked,
		futuristicHUDUnlocked: hudSkins.futuristic.unlocked,
		militaryHUDUnlocked: hudSkins.military.unlocked,
    }));
}

function loadSkinsUnlockStatus() {
    let storedSkins = localStorage.getItem('skins');
    if (storedSkins) {
        let data = JSON.parse(storedSkins);
        weaponSkins.golden.unlocked = data.goldenUnlocked || false;
        if (data.selectedHudSkin && hudSkins[data.selectedHudSkin]) {
            currentHudSkin = data.selectedHudSkin;
            applyHudSkin(currentHudSkin);
        }
		hudSkins.neon.unlocked = data.neonHUDUnlocked || false;
		hudSkins.retro.unlocked = data.retroHUDUnlocked || false;
		hudSkins.futuristic.unlocked = data.futuristicHUDUnlocked || false;
		hudSkins.military.unlocked = data.militaryHUDUnlocked || false;

		if (recordKillCount >= hudSkins.neon.requiredKills) hudSkins.neon.unlocked = true;
		if (recordKillCount >= hudSkins.retro.requiredKills) hudSkins.retro.unlocked = true;
		if (recordKillCount >= hudSkins.futuristic.requiredKills) hudSkins.futuristic.unlocked = true;
		if (recordKillCount >= hudSkins.military.requiredKills) hudSkins.military.unlocked = true;
    }
}

loadSkinsUnlockStatus();

function getRandomSpawnPosition() {
    let position;
    let isPositionValid = false;
    while (!isPositionValid) {
        position = new THREE.Vector3(
            (Math.random() - 0.5) * gameTileSize,
            1.6,
            (Math.random() - 0.5) * gameTileSize
        );
        isPositionValid = true;
        for (let i = 0; i < gameTrees.length; i++) {
            const treePosition = gameTrees[i];
            const distance = position.distanceTo(treePosition);
            if (distance < 5) {
                isPositionValid = false;
                break;
            }
        }
    }
    return position;
}

function reloadGun() {
    const gunWeapon = availableWeapons.find(weapon => weapon.id === 'weapon1');
    if (!gunWeapon || !gunWeapon.equipped || isGunReloading || currentGunAmmo === gunMagazineSize) {
        return;
    }
    isGunReloading = true;
    isGunAnimatingReload = true;
    gunReloadAnimationProgress = 0;
    updateHUDDisplay();
}

function showDeathModal() {
    const deathModalElement = document.getElementById('death-modal');
    deathModalElement.style.display = 'flex';
    document.getElementById('crosshair').style.display = 'none';
}

function saveGameProgress() {
    localStorage.setItem('killsRecord', recordKillCount);
}

function loadGameProgress() {
    const storedKillsRecord = localStorage.getItem('killsRecord');
    if (storedKillsRecord) {
        recordKillCount = parseInt(storedKillsRecord, 10);
    }
}

function updateMenuDisplay() {
    const killsDisplay = document.getElementById('kills-display');
    killsDisplay.textContent = recordKillCount;
    updateSkinsMenuDisplay();
}

loadGameProgress();
updateMenuDisplay();

function updateHealthBarDisplay() {
    const healthBar = document.getElementById('health');
    healthBar.style.width = currentPlayerHealth + '%';
    healthBar.textContent = currentPlayerHealth + '%';

    const mobileHealthBar = document.getElementById('mobile-health');
    mobileHealthBar.style.width = currentPlayerHealth + '%';
    mobileHealthBar.textContent = currentPlayerHealth + '%';
}

function takePlayerDamage(damageAmount) {
    currentPlayerHealth -= damageAmount;
    if (currentPlayerHealth <= 0) {
        currentPlayerHealth = 0;
        updateHealthBarDisplay();
        endGame();
        showDeathModal();
    } else {
        updateHealthBarDisplay();
    }
}

function createTreeInstance(positions) {
    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
    const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
    const trunkMesh = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, positions.length);
    const leavesGeometry = new THREE.ConeGeometry(1, 2, 8);
    const leavesMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
    const leavesMesh = new THREE.InstancedMesh(leavesGeometry, leavesMaterial, positions.length);
    const dummyObject = new THREE.Object3D();
    positions.forEach((pos, i) => {
        dummyObject.position.set(pos.x, pos.y, pos.z);
        dummyObject.updateMatrix();
        trunkMesh.setMatrixAt(i, dummyObject.matrix);
        dummyObject.position.set(pos.x, pos.y + 2, pos.z);
        dummyObject.updateMatrix();
        leavesMesh.setMatrixAt(i, dummyObject.matrix);
    });
    return { trunkMesh, leavesMesh };
}

function bossShoot() {
    const gunWeapon = availableWeapons.find(weapon => weapon.id === 'weapon1');
    if (!isGameCurrentlyActive || !gameBoss || !gunWeapon.equipped) return;
    const currentTime = performance.now() / 1000;
    if (currentTime - bossLastFireTime >= bossFireInterval) {
        bossLastFireTime = currentTime;

        for (let i = 0; i < 3; i++) {
            const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.userData.isBossBullet = true;
            const vapeMouthPiecePosition = new THREE.Vector3();
            const mouthPiece = bossWeaponGroup.children[0].children[0];
            mouthPiece.getWorldPosition(vapeMouthPiecePosition);
            bullet.position.copy(vapeMouthPiecePosition);

            const playerPosition = new THREE.Vector3();
            playerObject.getWorldPosition(playerPosition);

            const bulletDirection = new THREE.Vector3();
            bulletDirection.subVectors(playerPosition, vapeMouthPiecePosition).normalize();

            const spreadAngle = (i - 1) * 0.1;
            const axis = new THREE.Vector3(0, 1, 0);
            bulletDirection.applyAxisAngle(axis, spreadAngle);

            const bulletSpeed = 20.0;
            bullet.userData.direction = bulletDirection;
            bullet.userData.speed = bulletSpeed;
            bullet.userData.damage = currentBossDamage;
            gameScene.add(bullet);
            gameBullets.push(bullet);
        }

        gunMuzzleFlash.visible = true;
        gunMuzzleFlash.material.opacity = 0.5;
        setTimeout(() => {
            gunMuzzleFlash.visible = false;
        }, 200);
    }
}

function createBossHealthBar() {
    const width = 4;
    const height = 0.5;
    const borderThickness = 0.05;
    const healthBar = new THREE.Group();
    const backgroundGeometry = new THREE.PlaneGeometry(width, height);
    const backgroundMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
    background.position.set(0, 0, -0.01);
    healthBar.add(background);
    const healthGeometry = new THREE.PlaneGeometry(width - borderThickness * 2, height - borderThickness * 2);
    const healthMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const health = new THREE.Mesh(healthGeometry, healthMaterial);
    health.name = 'healthBar';
    healthBar.add(health);
    const healthTextCanvas = document.createElement('canvas');
    healthTextCanvas.width = 256;
    healthTextCanvas.height = 64;
    const healthTextContext = healthTextCanvas.getContext('2d');
    healthTextContext.font = 'Bold 40px Arial';
    healthTextContext.fillStyle = 'white';
    healthTextContext.textAlign = 'center';
    healthTextContext.fillText(baseBossHealth.toString(), healthTextCanvas.width / 2, healthTextCanvas.height / 2 + 14);
        const healthTextTexture = new THREE.CanvasTexture(healthTextCanvas);
    const healthTextMaterial = new THREE.SpriteMaterial({ map: healthTextTexture, transparent: true });
    const healthTextSprite = new THREE.Sprite(healthTextMaterial);
    healthTextSprite.scale.set(2, 0.5, 1);
    healthTextSprite.position.set(0, 0.5, 0);
    healthTextSprite.name = 'healthText';
    healthBar.add(healthTextSprite);
    healthBar.userData.textCanvas = healthTextCanvas;
healthBar.userData.textContext = healthTextContext;
    healthBar.userData.textTexture = healthTextTexture;
    return healthBar;
}

function updateBossHealthBar() {
    if (gameBoss && gameBoss.userData.healthBar) {
        const healthBar = gameBoss.userData.healthBar.getObjectByName('healthBar');
        const maxHealth = baseBossHealth;
        const healthPercent = bossHealth / maxHealth;
        const width = 4 - 0.05 * 2;
        healthBar.scale.x = healthPercent;
        healthBar.position.x = -width * (1 - healthPercent) / 2;
        const healthTextSprite = gameBoss.userData.healthBar.getObjectByName('healthText');
        const healthTextCanvas = gameBoss.userData.healthBar.userData.textCanvas;
        const healthTextContext = gameBoss.userData.healthBar.userData.textContext;
        const healthTextTexture = gameBoss.userData.healthBar.userData.textTexture;
        healthTextContext.clearRect(0, 0, healthTextCanvas.width, healthTextCanvas.height);
        healthTextContext.font = 'Bold 40px Arial';
        healthTextContext.fillStyle = 'white';
        healthTextContext.textAlign = 'center';
        healthTextContext.fillText(bossHealth.toString(), healthTextCanvas.width / 2, healthTextCanvas.height / 2 + 14);
        healthTextTexture.needsUpdate = true;
    }
}

function createBossEnemy() {
    for (let i = gameEnemies.length - 1; i >= 0; i--) {
        gameScene.remove(gameEnemies[i]);
    }
    gameEnemies.length = 0;

    let spawnPosition;
    if (gameEnemies.length > 0) {
        const randomEnemy = gameEnemies[Math.floor(Math.random() * gameEnemies.length)];
        const enemyPosition = randomEnemy.position.clone();
        const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            0,
            (Math.random() - 0.5) * 10
        );
        spawnPosition = enemyPosition.add(offset);
    } else {
        const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            0,
            (Math.random() - 0.5) * 10
        );
        spawnPosition = playerObject.position.clone().add(offset);
    }

    const bossTexture = new THREE.TextureLoader().load('https://i.postimg.cc/281t56C0/g-MVlsj-Khacjf82o-Zy764m-QTQ2a-Km2q5yp6h-VYXek.jpg');
    const bossMaterial = new THREE.MeshBasicMaterial({
        map: bossTexture,
        transparent: true,
        side: THREE.DoubleSide
    });
    const bossGeometry = new THREE.PlaneGeometry(3, 3);
    const bossMesh = new THREE.Mesh(bossGeometry, bossMaterial);
    bossMesh.userData.isBossMesh = true;
    gameBoss = new THREE.Object3D();
    gameBoss.add(bossMesh);
    gameBoss.position.copy(spawnPosition);
    bossHealth = baseBossHealth;

    const bossHealthBar = createBossHealthBar();
    bossHealthBar.position.set(gameBoss.position.x, gameBoss.position.y + 3.5, gameBoss.position.z);
    gameScene.add(bossHealthBar);
    gameBoss.userData.healthBar = bossHealthBar;
    gameScene.add(gameBoss);
    createBossWeaponModel();
}

function dropBossWeapon(position) {
    const droppedWeapon = new THREE.Group();

    const vapeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 32);
    const vapeMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const vapeMesh = new THREE.Mesh(vapeGeometry, vapeMaterial);
    vapeMesh.rotation.x = Math.PI / 2;
    droppedWeapon.add(vapeMesh);

    const ringGeometry = new THREE.RingGeometry(0.5, 0.7, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.6
    });
    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
    ringMesh.rotation.x = -Math.PI / 2;
    ringMesh.position.y = -0.2;
    droppedWeapon.add(ringMesh);

    droppedWeapon.position.copy(position);
    droppedWeapon.userData.isDroppedWeapon = true;

    gameScene.add(droppedWeapon);

    return droppedWeapon;
}

function createSwordWeaponModel() {
    const sword = new THREE.Group();
    const bladeGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.02);
    const bladeMaterial = new THREE.MeshBasicMaterial({ color: 0xAAAAAA });
    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
    blade.position.set(0, 0.75, 0);
    sword.add(blade);
    const handleGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
    handle.position.set(0, 0.15, 0);
    sword.add(handle);
    const guardGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
    const guardMaterial = new THREE.MeshBasicMaterial({ color: 0xDAA520 });
    const guard = new THREE.Mesh(guardGeometry, guardMaterial);
    guard.position.set(0, 0.35, 0);
    sword.add(guard);
    sword.rotation.z = Math.PI / 2;
    return sword;
}

function createEnemyHealthBar() {
    const barWidth = 1;
    const barHeight = 0.1;
    const healthBar = new THREE.Group();

    const backgroundGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
        const backgroundMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
    healthBar.add(background);

    const foregroundGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
    const foregroundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const foreground = new THREE.Mesh(foregroundGeometry, foregroundMaterial);
    foreground.position.z = 0.01;
    healthBar.add(foreground);

    const healthTextCanvas = document.createElement('canvas');
    healthTextCanvas.width = 128;
    healthTextCanvas.height = 32;
    const healthTextContext = healthTextCanvas.getContext('2d');
    healthTextContext.font = 'Bold 20px Arial';
    healthTextContext.fillStyle = 'white';
    healthTextContext.textAlign = 'center';
    healthTextContext.fillText(baseEnemyHealth.toString(), healthTextCanvas.width / 2, healthTextCanvas.height / 2 + 7);
        const healthTextTexture = new THREE.CanvasTexture(healthTextCanvas);
    const healthTextMaterial = new THREE.SpriteMaterial({ map: healthTextTexture, transparent: true });
    const healthTextSprite = new THREE.Sprite(healthTextMaterial);
    healthTextSprite.scale.set(1, 0.25, 1);
    healthTextSprite.position.set(0, 0.2, 0);
    healthBar.add(healthTextSprite);

    healthBar.userData.foreground = foreground;
    healthBar.userData.barWidth = barWidth;
    healthBar.userData.healthTextCanvas = healthTextCanvas;
    healthBar.userData.healthTextContext = healthTextContext;
    healthBar.userData.healthTextTexture = healthTextTexture;

    return healthBar;
}

function updateHealthBarForEnemy(enemy) {
    const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
    const healthBar = enemy.userData.healthBar;

    if (healthBar) {
        const foreground = healthBar.userData.foreground;
        foreground.scale.x = healthPercent;
        foreground.position.x = -(1 - healthPercent) * healthBar.userData.barWidth / 2;

        const healthTextContext = healthBar.userData.healthTextContext;
        const healthTextCanvas = healthBar.userData.healthTextCanvas;
        healthTextContext.clearRect(0, 0, healthTextCanvas.width, healthTextCanvas.height);
        healthTextContext.font = 'Bold 20px Arial';
        healthTextContext.fillStyle = 'white';
        healthTextContext.textAlign = 'center';
        healthTextContext.fillText(enemy.userData.health.toString(), healthTextCanvas.width / 2, healthTextCanvas.height / 2 + 7);
        healthBar.userData.healthTextTexture.needsUpdate = true;
    }
}

function createEnemyInTile(tileX, tileZ, ignoreMaxEnemies = false) {
    if (!isGameCurrentlyActive) return;
    if (gameBoss) return;
    if (!ignoreMaxEnemies && gameEnemies.length >= maxActiveEnemies) {
        return;
    }

    const enemy = new THREE.Object3D();
const enemyTexture = new THREE.TextureLoader().load(
               'https://i.postimg.cc/QC6j7xGC/photo-2024-05-28-17-49-00.jpg'
    );
    const enemyMaterial = new THREE.MeshBasicMaterial({
        map: enemyTexture,
        transparent: true,
        side: THREE.DoubleSide
    });
       const enemyGeometry = new THREE.PlaneGeometry(2, 2);
const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
    enemyMesh.userData.isEnemyMesh = true;
    enemy.add(enemyMesh);

    const sword = createSwordWeaponModel();
    sword.position.set(-0.5, -0.5, 0.4);
    sword.rotation.set(0, Math.PI / 2, 0);
    enemy.add(sword);

    const minX = tileX * gameTileSize;
    const maxX = minX + gameTileSize;
    const minZ = tileZ * gameTileSize;
    const maxZ = minZ + gameTileSize;
enemy.position.x = Math.random() * (maxX - minX) + minX;
    enemy.position.z = Math.random() * (maxZ - minZ) + minZ;
    enemy.position.y = 1;

    enemy.userData.health = baseEnemyHealth;
    enemy.userData.maxHealth = baseEnemyHealth;
    enemy.userData.damage = currentEnemyDamage;

    const healthBar = createEnemyHealthBar();
    healthBar.position.set(0, 2.5, 0);
    enemy.add(healthBar);
    enemy.userData.healthBar = healthBar;

    gameScene.add(enemy);
    gameEnemies.push(enemy);
}

function createVapeSmokeEffect() {
    const bulletCount = 3;
    const angleStep = 0.05;

    if (currentVapeWeaponAmmo < bulletCount) {
        return;
    }

    for (let i = 0; i < bulletCount; i++) {
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2
        });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.userData.isVapeBullet = true;
        bullet.userData.damage = 2;

        const cameraWorldPosition = new THREE.Vector3();
        gameCamera.getWorldPosition(cameraWorldPosition);
        const cameraWorldDirection = new THREE.Vector3();
        gameCamera.getWorldDirection(cameraWorldDirection);

        const spreadAngle = (i - Math.floor(bulletCount / 2)) * angleStep;
        const axis = new THREE.Vector3(0, 1, 0);
        cameraWorldDirection.applyAxisAngle(axis, spreadAngle);

        const bulletStartPositionOffset = cameraWorldDirection.clone().multiplyScalar(1);
        bullet.position.copy(cameraWorldPosition).add(bulletStartPositionOffset);
        bullet.userData.direction = cameraWorldDirection.clone();
        bullet.userData.speed = currentBulletSpeed;

        gameScene.add(bullet);
        playerGameBullets.push(bullet);

        cameraWorldDirection.applyAxisAngle(axis, -spreadAngle);
    }

    currentVapeWeaponAmmo -= bulletCount;
    updateHUDDisplay();
    gunMuzzleFlash.visible = true;
    gunMuzzleFlash.material.opacity = 1;
    const currentTimeSec = performance.now() / 1000;
    muzzleFlashEndTimeEpoch = currentTimeSec + 0.05;
}

function shootWeapon() {
     const currentWeapon = availableWeapons.find(weapon => weapon.id === currentEquippedWeaponId);

    if (!currentWeapon || !currentWeapon.equipped) return;

    if (currentEquippedWeaponId === 'weapon1') {
        if (currentGunAmmo <= 0) {
            return;
        }

        if (isGunReloading) return;

        const currentTime = performance.now() / 1000;
        if (currentTime - lastGunShotTime >= gunShotInterval) {
            lastGunShotTime = currentTime;
            createPlayerBullet();
            currentGunAmmo = Math.max(currentGunAmmo - 1, 0);
            displayedGunAmmo = currentGunAmmo;
            updateHUDDisplay();
        }
    } else if (currentEquippedWeaponId === 'weapon2') {
        if (currentVapeWeaponAmmo >= 3) {
            createVapeSmokeEffect();
        } else {
        }
    }
}

function createPlayerBullet() {
    const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
    const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
    bullet.userData.isPlayerBullet = true;
    bullet.userData.damage = 2;
    const cameraWorldPosition = new THREE.Vector3();
    gameCamera.getWorldPosition(cameraWorldPosition);
    const cameraWorldDirection = new THREE.Vector3();
    gameCamera.getWorldDirection(cameraWorldDirection);
    const bulletStartPositionOffset = cameraWorldDirection.clone().multiplyScalar(1);
    bullet.position.copy(cameraWorldPosition).add(bulletStartPositionOffset);
    bullet.userData.direction = cameraWorldDirection.clone();
    bullet.userData.speed = currentBulletSpeed;
    gameScene.add(bullet);
    playerGameBullets.push(bullet);
    gunMuzzleFlash.visible = true;
    gunMuzzleFlash.material.opacity = 1;
    const currentTimeSec = performance.now() / 1000;
    muzzleFlashEndTimeEpoch = currentTimeSec + 0.05;
}

function initScene() {
    gameScene = new THREE.Scene();
    gameScene.background = new THREE.Color(0x87CEEB);
    gameScene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
    gameCamera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
   gameRenderer = new THREE.WebGLRenderer({ antialias: false });
 gameRenderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(gameRenderer.domElement);
    playerObject = new THREE.Object3D();
    playerObject.position.set(0, 1.6, 0);
    gameScene.add(playerObject);
    playerObject.add(gameCamera);
    generateTilesAroundPlayer();
    createGunWeaponModel();
    createVapeWeaponModel();
    updateGunSkin();
    gunWeaponGroup.position.set(0.2, -0.2, -0.5);
    gameCamera.add(gunWeaponGroup);
    updateHUDDisplay();
    applyHudSkin(currentHudSkin);

}

document.addEventListener('mousedown', function(event) {
    if (isGameCurrentlyActive && isPointerLocked && event.button === 0) {
        event.preventDefault();
        isMouseButtonDown = true;
        shootWeapon();

        const currentWeapon = availableWeapons.find(weapon => weapon.id === currentEquippedWeaponId);
        if(currentWeapon && currentWeapon.id === 'weapon1'){
             shootIntervalTimerId = setInterval(shootWeapon, gunShotInterval * 1000);
        } else if (currentWeapon && currentWeapon.id === 'weapon2'){
             shootIntervalTimerId = setInterval(shootWeapon, 1000);
        }
    }
});

document.addEventListener('mouseup', function(event) {
    if (event.button === 0) {
        isMouseButtonDown = false;

        clearInterval(shootIntervalTimerId);
        shootIntervalTimerId = null;
    }
});

let isPointerLocked = false;

const pointerLockChange = function () {
    isPointerLocked = document.pointerLockElement === document.body;
};

document.addEventListener('pointerlockchange', pointerLockChange, false);

document.addEventListener('click', function () {
    if (isGameCurrentlyActive && !isPointerLocked && !isMobileControlsEnabled) {
        document.body.requestPointerLock();
    }
}, false);

document.addEventListener('mousemove', function (event) {
    if (isPointerLocked && isGameCurrentlyActive && !isMobileControlsEnabled) { 
        const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
        playerObject.rotation.y -= movementX * 0.002;
        gameCamera.rotation.x -= movementY * 0.002;
        gameCamera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameCamera.rotation.x));
        }
}, false);

let previousFrameTime = performance.now();

let lookTouchIdentifier = null;
let lookTouchLastX = 0;
let lookTouchLastY = 0;

document.body.addEventListener('touchstart', handleLookStart, { passive: false });
document.body.addEventListener('touchmove', handleLookMove, { passive: false });
document.body.addEventListener('touchend', handleLookEnd, { passive: false });
document.body.addEventListener('touchcancel', handleLookEnd, { passive: false });

function handleLookStart(e) {
    if (!isGameCurrentlyActive || !isMobileControlsEnabled) return;
    
    for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        const targetElement = touch.target;

        if (targetElement.closest('.action-button') || targetElement.closest('.joystick-base')) {
            continue; 
        }

        if (lookTouchIdentifier === null) {
            e.preventDefault();
            lookTouchIdentifier = touch.identifier;
            lookTouchLastX = touch.clientX;
            lookTouchLastY = touch.clientY;
            break; 
        }
    }
}

function handleLookMove(e) {
    if (!isGameCurrentlyActive || !isMobileControlsEnabled || lookTouchIdentifier === null) return;
    
    for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        if (touch.identifier === lookTouchIdentifier) {
            e.preventDefault();
            const movementX = touch.clientX - lookTouchLastX;
            const movementY = touch.clientY - lookTouchLastY;

            playerObject.rotation.y -= movementX * 0.002;
            gameCamera.rotation.x -= movementY * 0.002;
            gameCamera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameCamera.rotation.x));

            lookTouchLastX = touch.clientX;
            lookTouchLastY = touch.clientY;
            break;
        }
    }
}

function handleLookEnd(e) {
    if (lookTouchIdentifier === null) return;

    for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        if (touch.identifier === lookTouchIdentifier) {
            e.preventDefault();
            lookTouchIdentifier = null;
            break;
        }
    }
}

function animate() {
    const currentTime = performance.now();
    const deltaTime = (currentTime - previousFrameTime) / 1000;
    previousFrameTime = currentTime;
    requestAnimationFrame(animate);
    const previousPlayerPosition = playerObject.position.clone();
    
    playerVelocity.x -= playerVelocity.x * 10.0 * deltaTime;
    playerVelocity.z -= playerVelocity.z * 10.0 * deltaTime;
    
    playerDirection.z = Number(isMovingForward) - Number(isMovingBackward);
    playerDirection.x = Number(isMovingLeft) - Number(isMovingRight);
    playerDirection.normalize();
    
    const speed = 150.0;
    if (isMovingForward || isMovingBackward) playerVelocity.z -= playerDirection.z * speed * deltaTime;
    if (isMovingLeft || isMovingRight) playerVelocity.x -= playerDirection.x * speed * deltaTime;
    

    playerObject.translateX(playerVelocity.x * deltaTime);
    playerObject.translateZ(playerVelocity.z * deltaTime);

    playerVelocity.y -= gameGravity * deltaTime;
    playerObject.position.y += playerVelocity.y * deltaTime;

    if (playerObject.position.y <= 1.6) {
        playerObject.position.y = 1.6;
        playerVelocity.y = 0;
        isPlayerJumping = false;
        canPlayerJump = true;
    }

    if (isGameCurrentlyActive) {
        generateTilesAroundPlayer();
    }

    let isCollisionDetected = false;
    const playerPositionXZ = new THREE.Vector2(playerObject.position.x, playerObject.position.z);
    for (let i = 0; i < gameTrees.length; i++) {
        const treePosition = gameTrees[i];
        const treePositionXZ = new THREE.Vector2(treePosition.x, treePosition.z);
        const distance = playerPositionXZ.distanceTo(treePositionXZ);

        if (distance < 1.5 && playerObject.position.y < 4.0) {
            isCollisionDetected = true;
            break;
        }
    }

    if (isCollisionDetected) {
        playerObject.position.copy(previousPlayerPosition);
        if (playerVelocity.y > 0) {
            playerVelocity.y = 0;
        }
    }

    if (isGameCurrentlyActive) {
        updateBullets(deltaTime);
    }

    if (bossDroppedVapeWeapon && !hasPlayerPickedUpVapeWeapon) {
        const distanceToWeapon = playerObject.position.distanceTo(bossDroppedVapeWeapon.position);
        if (distanceToWeapon < 2) {
            hasPlayerPickedUpVapeWeapon = true;

            gameScene.remove(bossDroppedVapeWeapon);
            bossDroppedVapeWeapon = null;
            updateHUDDisplay();
        }
    }

    if (isGameCurrentlyActive) {
        for (let i = gameBullets.length - 1; i >= 0; i--) {
            const bullet = gameBullets[i];
            if (bullet.userData.isBossBullet) {
                const distanceToPlayer = bullet.position.distanceTo(playerObject.position);
                if (distanceToPlayer < 1.0) {
                    takePlayerDamage(bullet.userData.damage);
                    gameScene.remove(bullet);
                    gameBullets.splice(i, 1);
                    continue;
                }
            }
        }
        for (let i = playerGameBullets.length - 1; i >= 0; i--) {
            const bullet = playerGameBullets[i];
            if (bullet.userData.isPlayerBullet) {
                let bulletHitEnemy = false;
                for (let j = gameEnemies.length - 1; j >= 0; j--) {
                    const enemy = gameEnemies[j];
                    const distanceToEnemy = bullet.position.distanceTo(enemy.position);
                    if (distanceToEnemy < 1.5) {
                        enemy.userData.health -= bullet.userData.damage;
                        updateHealthBarForEnemy(enemy);
                        if (enemy.userData.health <= 0) {
                            gameScene.remove(enemy);
                            gameEnemies.splice(j, 1);
                            killCount++;
                            updateHUDDisplay();
                        }
                        gameScene.remove(bullet);
                        playerGameBullets.splice(i, 1);
                        bulletHitEnemy = true;
                        break;
                    }
                }
                if (gameBoss && !bulletHitEnemy) {
                    const distanceToBoss = bullet.position.distanceTo(gameBoss.position);
                    if (distanceToBoss < 2.5) {
                        bossHealth -= bullet.userData.damage;
                        if (bossHealth < 0) bossHealth = 0;
                        updateBossHealthBar();
                        gameScene.remove(bullet);
                        playerGameBullets.splice(i, 1);
                        bulletHitEnemy = true;
                        if (bossHealth <= 0) {
                            bossHealth = 0;
                            updateBossHealthBar();

                            killCount++;
                            updateHUDDisplay();
                            bossDroppedVapeWeapon = dropBossWeapon(gameBoss.position);
                            endBossFight();
                            generateEnemies();
                        }
                    }
                }
            } else if (bullet.userData.isVapeBullet) {
                let bulletHitEnemy = false;
                for (let j = gameEnemies.length - 1; j >= 0; j--) {
                    const enemy = gameEnemies[j];
                    const distanceToEnemy = bullet.position.distanceTo(enemy.position);
                    if (distanceToEnemy < 1.5) {
                        enemy.userData.health -= bullet.userData.damage;
                        updateHealthBarForEnemy(enemy);
                        if (enemy.userData.health <= 0) {
                            gameScene.remove(enemy);
                            gameEnemies.splice(j, 1);
                            killCount++;
                            updateHUDDisplay();
                        }
                        gameScene.remove(bullet);
                        playerGameBullets.splice(i, 1);
                        bulletHitEnemy = true;
                        break;
                    }
                }
                if (gameBoss && !bulletHitEnemy) {
                    const distanceToBoss = bullet.position.distanceTo(gameBoss.position);
                    if (distanceToBoss < 2.5) {
                        bossHealth -= bullet.userData.damage;
                        if (bossHealth < 0) bossHealth = 0;
                        updateBossHealthBar();
                        gameScene.remove(bullet);
                        playerGameBullets.splice(i, 1);
                        bulletHitEnemy = true;
                        if (bossHealth <= 0) {
                            bossHealth = 0;
                            updateBossHealthBar();

                            killCount++;
                            updateHUDDisplay();
                            bossDroppedVapeWeapon = dropBossWeapon(gameBoss.position);
                            endBossFight();
                            generateEnemies();
                        }
                    }
                }
            }
        }
    }

    if (isGameCurrentlyActive) {
        const currentTime = new Date().getTime();
        const elapsedTimeSinceLastIncrease = currentTime - lastDifficultyIncreaseGameTime;
        if (elapsedTimeSinceLastIncrease >= 2 * 60 * 1000) {
            currentEnemySpeed *= 1.1;
            maxActiveEnemies += 3;
            if (currentEnemySpeed > 10.0) currentEnemySpeed = 10.0;
            if (maxActiveEnemies > 25) maxActiveEnemies = 25;
            lastDifficultyIncreaseGameTime = currentTime;
        }

        const enemyUpdateDistance = 3000;
        const maxEnemyDistance = 5000;

        for (let i = gameEnemies.length - 1; i >= 0; i--) {
            const enemy = gameEnemies[i];
            const distanceToPlayer = enemy.position.distanceTo(playerObject.position);

            if (distanceToPlayer < enemyUpdateDistance) {
                let enemyDirection = new THREE.Vector3();
                enemyDirection.subVectors(playerObject.position.clone().setY(0), enemy.position.clone().setY(0));
                enemyDirection.normalize();

                let avoidDirection = new THREE.Vector3(0, 0, 0);
                let isObstacleDetected = false;

                for (let j = 0; j < gameTrees.length; j++) {
                    const treePosition = gameTrees[j];
                    const distanceToTree = enemy.position.distanceTo(treePosition);
                    if (distanceToTree < 3) {
                        let offset = new THREE.Vector3();
                        offset.subVectors(enemy.position, treePosition);
                        offset.y = 0;
                        offset.normalize();
                        offset.divideScalar(distanceToTree);
                        avoidDirection.add(offset);
                        isObstacleDetected = true;
                    }
                }

                if (isObstacleDetected) {
                    avoidDirection.normalize();
                    enemyDirection.add(avoidDirection);
                    enemyDirection.normalize();
                }

                enemy.position.addScaledVector(enemyDirection, currentEnemySpeed * deltaTime);
                enemy.position.y = 1;

                enemy.traverse(function(child) {
                    if (child.userData.isEnemyMesh) {
                        const enemyPositionWorld = new THREE.Vector3();
                        enemy.getWorldPosition(enemyPositionWorld);
                        const cameraPositionWorld = new THREE.Vector3();
                        gameCamera.getWorldPosition(cameraPositionWorld);
                        const dx = cameraPositionWorld.x - enemyPositionWorld.x;
                        const dz = cameraPositionWorld.z - enemyPositionWorld.z;
                        const angle = Math.atan2(dx, dz);
                        enemy.rotation.set(0, angle, 0);
                    }
                });

                if (distanceToPlayer < 1.5 && Math.abs(playerObject.position.y - enemy.position.y) < 2.0) {
                    takePlayerDamage(enemy.userData.damage);
                }

                if (distanceToPlayer < 10) {
                    if (enemy.userData.healthBar) {
                        enemy.userData.healthBar.visible = true;
                        enemy.userData.healthBar.rotation.copy(gameCamera.rotation);
                    }
                } else {
                    if (enemy.userData.healthBar) {
                        enemy.userData.healthBar.visible = false;
                    }
                }
            } else {
                enemy.position.y = 1;
            }

            if (distanceToPlayer > maxEnemyDistance) {
                gameScene.remove(enemy);
                gameEnemies.splice(i, 1);
            }
        }

        if (gameBoss) {
            const distanceToPlayer = gameBoss.position.distanceTo(playerObject.position);
            if (distanceToPlayer < enemyUpdateDistance) {
                let bossDirection = new THREE.Vector3();
                bossDirection.subVectors(playerObject.position.clone().setY(0), gameBoss.position.clone().setY(0));
                bossDirection.normalize();

                let avoidDirection = new THREE.Vector3(0, 0, 0);
                let isObstacleDetected = false;
                for (let j = 0; j < gameTrees.length; j++) {
                    const treePos = gameTrees[j];
                    const distanceToTree = gameBoss.position.distanceTo(treePos);

                    if (distanceToTree < 3) {
                        let offset = new THREE.Vector3();
                        offset.subVectors(gameBoss.position, treePos);
                        offset.y = 0;
                        offset.normalize();
                        offset.divideScalar(distanceToTree);

                        avoidDirection.add(offset);
                        isObstacleDetected = true;
                    }
                }

                if (isObstacleDetected) {
                    avoidDirection.normalize();
                    bossDirection.add(avoidDirection);
                    bossDirection.normalize();
                }

                gameBoss.position.addScaledVector(bossDirection, currentEnemySpeed * deltaTime * 0.5);
                gameBoss.position.y = 1;

               gameBoss.traverse(function(child) {
    if (child.userData.isBossMesh) {
        const bossPositionWorld = new THREE.Vector3();
        gameBoss.getWorldPosition(bossPositionWorld);
        const playerPositionWorld = new THREE.Vector3();
        gameCamera.getWorldPosition(playerPositionWorld);
        const dx = playerPositionWorld.x - bossPositionWorld.x;
        const dz = playerPositionWorld.z - bossPositionWorld.z;
        const angle = Math.atan2(dx, dz);
        gameBoss.rotation.set(0, angle, 0);
    }
});

                if (distanceToPlayer < 2.5 && Math.abs(playerObject.position.y - gameBoss.position.y) < 2.0) {
                    takePlayerDamage(currentBossDamage);
                }
                bossShoot();
            } else {
                gameBoss.position.y = 1;
            }

            if (gameBoss && gameBoss.userData.healthBar) {
                gameBoss.userData.healthBar.position.copy(gameBoss.position).add(new THREE.Vector3(0, 3.5, 0));
                const directionToPlayer = new THREE.Vector3();
                directionToPlayer.subVectors(playerObject.position, gameBoss.userData.healthBar.position).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const matrix = new THREE.Matrix4();
                matrix.lookAt(playerObject.position, gameBoss.userData.healthBar.position, up);
                gameBoss.userData.healthBar.quaternion.setFromRotationMatrix(matrix);
            }
        }

        const currentTimeSec = (new Date().getTime() - gameStartTimeEpoch) / 1000;
        if (!isBossAlreadySpawned && currentTimeSec >= timeToNextBossSpawn) {
            isBossAlreadySpawned = true;
            createBossEnemy();
        }
    }

    const currentTimeSec = currentTime / 1000;
    if (currentTimeSec >= muzzleFlashEndTimeEpoch) {
        gunMuzzleFlash.visible = false;
    } else {
        gunMuzzleFlash.visible = true;
        const remainingTime = muzzleFlashEndTimeEpoch - currentTimeSec;
        gunMuzzleFlash.material.opacity = remainingTime / 0.05;
    }

    if (isGunAnimatingReload) {
        gunReloadAnimationProgress += deltaTime;
        const halfDuration = gunReloadAnimationDuration / 2;
        if (gunReloadAnimationProgress <= halfDuration) {
                       const t = gunReloadAnimationProgress / halfDuration;
            gunWeaponMagazine.position.y = THREE.MathUtils.lerp(-0.25, -0.5, t);
        } else if (gunReloadAnimationProgress <= gunReloadAnimationDuration) {
                       const t = (gunReloadAnimationProgress - halfDuration) / halfDuration;
            gunWeaponMagazine.position.y = THREE.MathUtils.lerp(-0.5, -0.25, t);
        } else {
            gunWeaponMagazine.position.y = -0.25;
            isGunAnimatingReload = false;
            currentGunAmmo = gunMagazineSize;
            isGunReloading = false;
            displayedGunAmmo = currentGunAmmo;
            updateHUDDisplay();
        }
    }

    regenerateVapeAmmo(deltaTime);
    handleCollisions();
    TWEEN.update();

    if (isGameCurrentlyActive) {
        updateHUDDisplay();
    }

    gameRenderer.render(gameScene, gameCamera);
}

document.addEventListener('DOMContentLoaded', () => {
    const joystickBase = document.getElementById('joystick-base');
    const joystickThumb = document.getElementById('joystick-thumb');
    const shootButton = document.getElementById('shoot-button');
    const jumpButton = document.getElementById('jump-button');
    const reloadButton = document.getElementById('reload-button');
    const weapon1Button = document.getElementById('weapon1-button');
    const weapon2Button = document.getElementById('weapon2-button');
    
    joystickBase.addEventListener('touchstart', handleJoystickStart, { passive: false });
    joystickBase.addEventListener('touchmove', handleJoystickMove, { passive: false });
    joystickBase.addEventListener('touchend', handleJoystickEnd, { passive: false });
    
    shootButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isGameCurrentlyActive) {
            isMouseButtonDown = true;
            shootWeapon();
            const currentWeapon = availableWeapons.find(w => w.id === currentEquippedWeaponId);
            if (currentWeapon) {
                shootIntervalTimerId = setInterval(shootWeapon, 
                    currentWeapon.id === 'weapon1' ? gunShotInterval * 1000 : 1000);
            }
        }
    }, { passive: false });
    
    shootButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        isMouseButtonDown = false;
        clearInterval(shootIntervalTimerId);
        shootIntervalTimerId = null;
    }, { passive: false });
    
    jumpButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isGameCurrentlyActive && canPlayerJump && !isPlayerJumping) {
            isPlayerJumping = true;
            canPlayerJump = false;
            playerVelocity.y = playerJumpStrength;
        }
    }, { passive: false });
    
    reloadButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isGameCurrentlyActive) {
            reloadGun();
        }
    }, { passive: false });
    
    weapon1Button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isGameCurrentlyActive) {
            setEquippedWeapon('weapon1');
        }
    }, { passive: false });
    
    weapon2Button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isGameCurrentlyActive && hasPlayerPickedUpVapeWeapon) {
            setEquippedWeapon('weapon2');
        }
    }, { passive: false });
    
    function handleJoystickStart(e) {
        e.preventDefault();
        isJoystickActive = true;
        updateJoystick(e.touches[0]);
    }
    
    function handleJoystickMove(e) {
        e.preventDefault();
        if (isJoystickActive) {
            updateJoystick(e.touches[0]);
        }
    }
    
    function handleJoystickEnd(e) {
        e.preventDefault();
        isJoystickActive = false;
        joystickDeltaX = 0;
        joystickDeltaY = 0;
        joystickThumb.style.transform = 'translate(0px, 0px)';
        
        isMovingForward = false;
        isMovingBackward = false;
        isMovingLeft = false;
        isMovingRight = false;
    }
    
    function updateJoystick(touch) {
        const rect = joystickBase.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const touchX = touch.clientX;
        const touchY = touch.clientY;
        
        const deltaX = touchX - centerX;
        const deltaY = touchY - centerY;
        
        const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50);
        const angle = Math.atan2(deltaY, deltaX);
        
        const clampedX = Math.cos(angle) * distance;
        const clampedY = Math.sin(angle) * distance;
        
        joystickThumb.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
        
        joystickDeltaX = clampedX / 50;
        joystickDeltaY = clampedY / 50;
        
        if (joystickDeltaY < -0.3) {
            isMovingForward = true;
            isMovingBackward = false;
        } else if (joystickDeltaY > 0.3) {
            isMovingForward = false;
            isMovingBackward = true;
        } else {
            isMovingForward = false;
            isMovingBackward = false;
        }
        
        if (joystickDeltaX < -0.3) {
            isMovingLeft = true;
            isMovingRight = false;
        } else if (joystickDeltaX > 0.3) {
            isMovingLeft = false;
            isMovingRight = true;
        } else {
            isMovingLeft = false;
            isMovingRight = false;
        }
    }
});


function updateBullets(deltaTime) {
    for (let i = gameBullets.length - 1; i >= 0; i--) {
        const bullet = gameBullets[i];
        bullet.position.add(bullet.userData.direction.clone().multiplyScalar(bullet.userData.speed * deltaTime));
        bullet.material.opacity -= deltaTime * 0.5;
        if (bullet.material.opacity <= 0) {
            gameScene.remove(bullet);
            gameBullets.splice(i, 1);
            continue;
        }
        if (bullet.position.distanceTo(playerObject.position) > 500) {
            gameScene.remove(bullet);
            gameBullets.splice(i, 1);
        }
    }

    for (let i = playerGameBullets.length - 1; i >= 0; i--) {
        const bullet = playerGameBullets[i];
        bullet.position.add(bullet.userData.direction.clone().multiplyScalar(bullet.userData.speed * deltaTime));
         if (bullet.userData.isVapeBullet) {
            bullet.material.opacity -= deltaTime * 0.5;
            if (bullet.material.opacity <= 0) {
                gameScene.remove(bullet);
                playerGameBullets.splice(i, 1);
                continue;
            }
        }
        if (bullet.position.distanceTo(playerObject.position) > 500) {
            gameScene.remove(bullet);
            playerGameBullets.splice(i, 1);
        }
    }
}

function updateHealthBarsRotation() {
    gameEnemies.forEach(enemy => {
        if (enemy.userData.healthBar) {
            enemy.userData.healthBar.rotation.copy(gameCamera.rotation);
        }
    });
}

function handleCollisions() {
    playerGameBullets.forEach((bullet, index) => {
        gameEnemies.forEach(enemy => {
            if (bullet.position.distanceTo(enemy.position) < 1.5) {
                enemy.userData.health -= bullet.userData.damage;
                gameScene.remove(bullet);
                playerGameBullets.splice(index, 1);
                if (enemy.userData.health <= 0) {
                    killCount++;
                    updateHUDDisplay();
                }
            }
        });
    });
}

function generateTilesAroundPlayer() {
    const playerTileX = Math.floor(playerObject.position.x / gameTileSize);
    const playerTileZ = Math.floor(playerObject.position.z / gameTileSize);
    const range = 2;

    for (let x = playerTileX - range; x <= playerTileX + range; x++) {
        for (let z = playerTileZ - range; z <= playerTileZ + range; z++) {
            const tileKey = `${x},${z}`;
            if (!gameTiles[tileKey]) {
                createTile(x, z);
            }
        }
    }

    for (let key in gameTiles) {
        const [tileX, tileZ] = key.split(',').map(Number);
        if (Math.abs(tileX - playerTileX) > range + 1 || Math.abs(tileZ - playerTileZ) > range + 1) {
            removeTile(tileX, tileZ);
        }
    }
}

function createTile(x, z) {
    const tileGeometry = new THREE.PlaneGeometry(gameTileSize, gameTileSize);
    const tileMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
    const tile = new THREE.Mesh(tileGeometry, tileMaterial);
    tile.rotation.x = -Math.PI / 2;
    tile.position.set(x * gameTileSize + gameTileSize / 2, 0, z * gameTileSize + gameTileSize / 2);
    gameScene.add(tile);
    gameTileMeshes[`${x},${z}`] = tile;
    gameTiles[`${x},${z}`] = true;

    const numTrees = 9;
    const positions = [];
    for (let i = 0; i < numTrees; i++) {
        const treeX = x * gameTileSize + Math.random() * gameTileSize;
        const treeZ = z * gameTileSize + Math.random() * gameTileSize;
        positions.push(new THREE.Vector3(treeX, 0, treeZ));
    }

    const { trunkMesh, leavesMesh } = createTreeInstance(positions);
    gameScene.add(trunkMesh);
    gameScene.add(leavesMesh);
    gameTrees.push(...positions);
    gameTreeInstances[`${x},${z}`] = { trunkMesh, leavesMesh, positions };

    const enemiesPerTile = 3;
    for (let i = 0; i < enemiesPerTile; i++) {
        createEnemyInTile(x, z, true);
    }
}

function removeTile(x, z) {
    const tileKey = `${x},${z}`;
    const tile = gameTileMeshes[tileKey];
    if (tile) {
        gameScene.remove(tile);
        delete gameTileMeshes[tileKey];
    }

    const treeInstance = gameTreeInstances[tileKey];
    if (treeInstance) {
        gameScene.remove(treeInstance.trunkMesh);
        gameScene.remove(treeInstance.leavesMesh);
        treeInstance.positions.forEach(pos => {
            const index = gameTrees.findIndex(treePos => treePos.equals(pos));
            if (index > -1) {
                gameTrees.splice(index, 1);
            }
        });
        delete gameTreeInstances[tileKey];
    }

    for (let i = gameEnemies.length - 1; i >= 0; i--) {
        const enemy = gameEnemies[i];
        const enemyTileX = Math.floor(enemy.position.x / gameTileSize);
        const enemyTileZ = Math.floor(enemy.position.z / gameTileSize);
        if (enemyTileX === x && enemyTileZ === z) {
            gameScene.remove(enemy);
            gameEnemies.splice(i, 1);
        }
    }

    delete gameTiles[tileKey];
}


function startGame() {
    const menuElement = document.getElementById('menu');
    menuElement.style.display = 'none';
    const deathModalElement = document.getElementById('death-modal');
    deathModalElement.style.display = 'none';
    
    if (isMobileControlsEnabled) {
        document.getElementById('mobile-hud').style.display = 'flex'; 
        document.getElementById('mobile-health-bar').style.display = 'block';
        document.getElementById('mobile-controls').style.display = 'block';
        
        document.getElementById('hud').style.display = 'none';
        document.getElementById('health-bar').style.display = 'none';
    } else {
        document.getElementById('hud').style.display = 'block';
        document.getElementById('health-bar').style.display = 'block';
        
        document.getElementById('mobile-hud').style.display = 'none';
        document.getElementById('mobile-health-bar').style.display = 'none';
        document.getElementById('mobile-controls').style.display = 'none';
    }
    
    document.getElementById('crosshair').style.display = 'block';

    hasPlayerPickedUpVapeWeapon = false;
    bossDroppedVapeWeapon = null;

    currentEquippedWeaponId = isMobileControlsEnabled ? '' : 'weapon1'; 

    const settings = difficultySettings[currentDifficulty];
    baseEnemyHealth = settings.enemyHealth;
    baseBossHealth = settings.bossHealth;

    killCount = 0;
    currentPlayerHealth = 100;
    currentBossLevel = 1;
    isBossAlreadySpawned = false;
    timeToNextBossSpawn = 300;
    currentEnemyDamage = 1;
    currentBossDamage = 2;
    updateHealthBarDisplay();
    currentGunAmmo = gunMagazineSize;
    displayedGunAmmo = gunMagazineSize;
    isGunReloading = false;
    isGunAnimatingReload = false;
    gunReloadAnimationProgress = 0;
    currentVapeWeaponAmmo = vapeWeaponAmmo;
    updateHUDDisplay(); 
    clearGameObjects();
    playerObject.position.copy(getRandomSpawnPosition());
    playerObject.rotation.set(0, 0, 0);
    gameCamera.rotation.set(0, 0, 0);
    playerVelocity.x = 0;
    playerVelocity.y = 0;
    playerVelocity.z = 0;
    gameStartTimeEpoch = new Date().getTime();
    isGameCurrentlyActive = true;
    currentEnemySpeed = 5.0;
    maxActiveEnemies = 25;
    lastDifficultyIncreaseGameTime = gameStartTimeEpoch;
    gameEnemies.length = 0;
    gameBoss = null;
    generateTilesAroundPlayer();
    if (!isMobileControlsEnabled) {
        document.body.requestPointerLock();
    }
	document.getElementById('toggle-versions').style.display = 'none';
    document.getElementById('version-info').style.display = 'none';
    applyHudSkin(currentHudSkin);
}

function endBossFight() {
    if (gameBoss && gameBoss.userData.healthBar) {
        gameScene.remove(gameBoss.userData.healthBar);
        gameBoss.userData.healthBar = null;
    }
    if (gameBoss) {
        gameScene.remove(gameBoss);
        gameBoss = null;
    }
    isBossAlreadySpawned = false;
    currentBossLevel++;

    timeToNextBossSpawn = currentBossLevel * 300;

    baseBossHealth += 50;
    currentBossDamage += 2;
    baseEnemyHealth += 10;
    currentEnemyDamage += 1;

    gameEnemies.forEach(enemy => {
        enemy.userData.maxHealth = baseEnemyHealth;
        enemy.userData.health = baseEnemyHealth;
        enemy.userData.damage = currentEnemyDamage;
        updateHealthBarForEnemy(enemy);
    });
}

function generateEnemies() {
    const tilesToGenerate = Object.keys(gameTiles);
    tilesToGenerate.forEach(tileKey => {
        const [x, z] = tileKey.split(',').map(Number);
        const enemiesPerTile = 3;
        for (let i = 0; i < enemiesPerTile; i++) {
            createEnemyInTile(x, z, true);
        }
    });
}

function endGame() {
    gameEndTimeEpoch = new Date().getTime();
    isGameCurrentlyActive = false;
    document.exitPointerLock();
    document.getElementById('crosshair').style.display = 'none';

    hasPlayerPickedUpVapeWeapon = false;
    currentEquippedWeaponId = '';
    updateHUDDisplay();

    if (killCount > recordKillCount) {
        recordKillCount = killCount;
        saveGameProgress();
    }
    if (recordKillCount >= 1000) {
        weaponSkins.golden.unlocked = true;
        saveSkinsUnlockStatus();
    }

	if (recordKillCount >= hudSkins.neon.requiredKills) hudSkins.neon.unlocked = true;
	if (recordKillCount >= hudSkins.retro.requiredKills) hudSkins.retro.unlocked = true;
	if (recordKillCount >= hudSkins.futuristic.requiredKills) hudSkins.futuristic.unlocked = true;
	if (recordKillCount >= hudSkins.military.requiredKills) hudSkins.military.unlocked = true;
	saveSkinsUnlockStatus();

    updateMenuDisplay();
    document.getElementById('mobile-controls').style.display = 'none';
}

function clearGameObjects() {
    gameEnemies.forEach(enemy => gameScene.remove(enemy));
    gameEnemies.length = 0;
    if (gameBoss) {
        gameScene.remove(gameBoss);
        gameBoss = null;
    }
    gameBullets.forEach(bullet => gameScene.remove(bullet));
    gameBullets.length = 0;
    playerGameBullets.forEach(bullet => gameScene.remove(bullet));
    playerGameBullets.length = 0;

    for (let key in gameTileMeshes) {
        gameScene.remove(gameTileMeshes[key]);
    }
    for (let key in gameTreeInstances) {
        gameScene.remove(gameTreeInstances[key].trunkMesh);
        gameScene.remove(gameTreeInstances[key].leavesMesh);
    }

    gameTiles = {};
    gameTileMeshes = {};
    gameTreeInstances = {};
    gameTrees.length = 0;
}

const restartButtonElement = document.getElementById('restartButton');
const returnToMenuButtonElement = document.getElementById('returnToMenuButton');
const menuContainerElement = document.getElementById('menu-container');

restartButtonElement.addEventListener('click', function(event) {
    event.stopPropagation();
    const deathModalElement = document.getElementById('death-modal');
    deathModalElement.style.display = 'none';
    startGame();
});

returnToMenuButtonElement.addEventListener('click', function(event) {
  event.stopPropagation();
  const deathModalElement = document.getElementById('death-modal');
  deathModalElement.style.display = 'none';
  document.getElementById('crosshair').style.display = 'none';
  const menuElement = document.getElementById('menu');
  menuElement.style.display = 'flex';
  menuContainerElement.style.display = 'flex';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('health-bar').style.display = 'none';
  document.getElementById('mobile-hud').style.display = 'none';
  document.getElementById('mobile-health-bar').style.display = 'none';
  document.getElementById('mobile-controls').style.display = 'none';
  isGameCurrentlyActive = false;
  toggleVersionButton.style.display = 'block';
  toggleVersionButton.textContent = 'Показать версии';
  versionInfoDisplayElement.style.display = 'none';
});

const playButtonElement = document.getElementById('playButton');
playButtonElement.addEventListener('click', function(event) {
    event.stopPropagation();
    startGame();
    menuContainerElement.style.display = 'none';
});

window.addEventListener('resize', function() {
    gameCamera.aspect = window.innerWidth / window.innerHeight;
    gameCamera.updateProjectionMatrix();
    gameRenderer.setSize(window.innerWidth, window.innerHeight);
}, false);

loadGameProgress();
loadSkinsUnlockStatus();
applyHudSkin(currentHudSkin);
initScene();
updateGunSkin();
updateMenuDisplay();
updateHealthBarDisplay();
updateHUDDisplay();
animate();
</script>
<div id="version">Версия 0.0.1.0(mobile-update)</div>
</body>
</html>